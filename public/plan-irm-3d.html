<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Plan 3D Architecte — IRM Mobile T350 14' — Faucon PTR</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#060608;color:#e5e5e5;font-family:'Segoe UI',system-ui,sans-serif;overflow:hidden;width:100vw;height:100vh}
  #c{position:fixed;top:0;left:0;width:100%;height:100%}
  #vig{position:fixed;inset:0;pointer-events:none;z-index:50;box-shadow:inset 0 0 160px rgba(0,0,0,.5)}
  #ld{position:fixed;inset:0;background:#060608;z-index:999;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;transition:opacity .8s}
  #ld.hide{opacity:0;pointer-events:none}
  #ld .sp{width:30px;height:30px;border:3px solid #1a1a1a;border-top-color:#f59e0b;border-radius:50%;animation:spin .8s linear infinite}
  #ld p{font-size:11px;color:#404040}
  @keyframes spin{to{transform:rotate(360deg)}}
  #err{position:fixed;inset:0;background:#060608;z-index:1000;display:none;align-items:center;justify-content:center;flex-direction:column;gap:12px;padding:40px}
  #err h2{color:#ef4444;font-size:18px}#err p{color:#666;font-size:13px;max-width:500px;text-align:center}#err code{background:#141414;padding:8px 16px;border-radius:8px;font-size:11px;color:#f87171;max-width:90vw;overflow-x:auto}
  .P{position:fixed;top:14px;left:14px;background:rgba(6,6,8,.92);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:16px;width:240px;z-index:100;max-height:calc(100vh - 28px);overflow-y:auto;scrollbar-width:thin;scrollbar-color:#222 transparent}
  .P h1{font-size:16px;font-weight:700}.P h1 span{color:#f59e0b}
  .P .sub{font-size:9px;color:#404040;margin-bottom:12px;letter-spacing:.4px}
  .S{font-size:8px;text-transform:uppercase;letter-spacing:1.3px;color:#333;margin:12px 0 5px;font-weight:700}
  .vb{display:inline-block;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);border-radius:6px;color:#666;font-size:9.5px;padding:4px 9px;margin:2px;cursor:pointer;transition:all .15s;font-family:inherit}
  .vb:hover{border-color:#f59e0b;color:#f59e0b}.vb.on{background:rgba(245,158,11,.15);color:#f59e0b;border-color:rgba(245,158,11,.3);font-weight:600}
  .tr{display:flex;align-items:center;gap:6px;padding:2.5px 0}
  .tr input{accent-color:#f59e0b;cursor:pointer;width:13px;height:13px}
  .tr label{font-size:10.5px;color:#888;cursor:pointer}
  .dot{width:6px;height:6px;border-radius:2px;flex-shrink:0}
  .sg{display:grid;grid-template-columns:1fr 1fr;gap:2px;margin-top:3px}
  .si{font-size:8.5px;color:#444;padding:2px 0}.si strong{color:#888;display:block;font-size:9.5px}
  .lk{display:inline-block;margin-top:8px;font-size:9.5px;color:#f59e0b;text-decoration:none;opacity:.5;transition:opacity .2s}.lk:hover{opacity:1}
  .bb{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:100}
  .bb>div,.bb>button{background:rgba(6,6,8,.85);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.05);border-radius:8px;padding:5px 12px;font-size:9.5px;color:#555;font-family:inherit}
  .bb button{cursor:pointer;transition:all .15s;color:#888}.bb button:hover{border-color:#f59e0b;color:#f59e0b}
  .fs{position:fixed;top:14px;right:14px;background:rgba(6,6,8,.9);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.05);border-radius:8px;padding:6px 10px;color:#555;font-size:15px;cursor:pointer;z-index:100;transition:all .15s;line-height:1}.fs:hover{border-color:#f59e0b;color:#f59e0b}
  .l3{background:rgba(4,4,6,.85);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.07);border-radius:5px;padding:3px 7px;font-size:9.5px;font-weight:600;white-space:nowrap;pointer-events:none;font-family:'Segoe UI',system-ui,sans-serif;line-height:1.35}
  .l3.ci{color:#fbbf24;border-color:rgba(245,158,11,.2)}.l3.ct{color:#c084fc;border-color:rgba(168,85,247,.2)}
  .l3.cz{color:#f87171;border-color:rgba(239,68,68,.2)}.l3.ce{color:#60a5fa;border-color:rgba(59,130,246,.2)}
  .l3.cs{color:#34d399;border-color:rgba(16,185,129,.2)}.l3.cd{color:rgba(245,158,11,.6);border-color:rgba(245,158,11,.1);font-weight:400;font-size:8.5px}
  .l3 .dm{font-size:7.5px;font-weight:400;opacity:.55;display:block}
  @media(max-width:640px){.P{width:185px;padding:10px}}
</style>
</head>
<body>

<div id="ld"><div class="sp"></div><p>Chargement de la scène 3D…</p></div>
<div id="err"><h2>Erreur de chargement</h2><p>Le rendu 3D n'a pas pu démarrer.</p><code id="errmsg"></code><p style="margin-top:12px"><a href="plan-irm.html" style="color:#f59e0b">← Voir le plan 2D</a></p></div>
<div id="c"></div>
<div id="vig"></div>

<div class="P">
  <h1>FAUCON <span>PTR</span></h1>
  <div class="sub">IRM Mobile T350 14' — Visualisation 3D architecte</div>
  <div class="S">Vues</div>
  <div>
    <button class="vb on" data-v="hero">Perspective</button>
    <button class="vb" data-v="top">Dessus</button>
    <button class="vb" data-v="drv">Conducteur</button>
    <button class="vb" data-v="pas">Passager</button>
    <button class="vb" data-v="rear">Arrière</button>
    <button class="vb" data-v="bore">Détail bore</button>
    <button class="vb" data-v="pat">Vue patient</button>
  </div>
  <div class="S">Rendu</div>
  <div class="tr"><input type="checkbox" id="t-real"><label for="t-real">Mode réaliste (couleurs IRM)</label></div>
  <div class="S">Éléments</div>
  <div class="tr"><input type="checkbox" id="t-i" checked><div class="dot" style="background:#f59e0b"></div><label for="t-i">IRM (1.0×0.82×1.50m)</label></div>
  <div class="tr"><input type="checkbox" id="t-t" checked><div class="dot" style="background:#a855f7"></div><label for="t-t">Table patient (1.82×0.75m)</label></div>
  <div class="tr"><input type="checkbox" id="t-z" checked><div class="dot" style="background:#ef4444"></div><label for="t-z">Zone dégagement 90°/1m</label></div>
  <div class="tr"><input type="checkbox" id="t-e" checked><div class="dot" style="background:#3b82f6"></div><label for="t-e">Armoire électrique 30"³</label></div>
  <div class="tr"><input type="checkbox" id="t-s" checked><div class="dot" style="background:#10b981"></div><label for="t-s">Rangement</label></div>
  <div class="tr"><input type="checkbox" id="t-l" checked><label for="t-l">Labels</label></div>
  <div class="tr"><input type="checkbox" id="t-w" checked><label for="t-w">Parois</label></div>
  <div class="S">Véhicule</div>
  <div class="sg">
    <div class="si"><strong>Long.</strong>4.00 m</div>
    <div class="si"><strong>Larg.</strong>2.045 m</div>
    <div class="si"><strong>Haut.</strong>1.98 m</div>
    <div class="si"><strong>Dég.</strong>1.0m / 90°</div>
  </div>
  <a href="plan-irm.html" class="lk">← Plan 2D technique</a>
</div>

<div class="bb">
  <div>Clic : rotation · Molette : zoom · Clic droit : pan</div>
  <button id="cap">Capture HD</button>
</div>
<button class="fs" id="fs" title="Plein écran">⛶</button>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
<script type="module">
try {

/* ── Imports ── */
const THREE = await import('three');
const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
const { CSS2DRenderer, CSS2DObject } = await import('three/addons/renderers/CSS2DRenderer.js');

let RoomEnv = null;
try {
  const mod = await import('three/addons/environments/RoomEnvironment.js');
  RoomEnv = mod.RoomEnvironment;
} catch(e) { console.warn('RoomEnvironment unavailable:', e); }

let BloomPass = null, EffComp = null, RenPass = null, OutPass = null;
try {
  const [ec, rp, bp, op] = await Promise.all([
    import('three/addons/postprocessing/EffectComposer.js'),
    import('three/addons/postprocessing/RenderPass.js'),
    import('three/addons/postprocessing/UnrealBloomPass.js'),
    import('three/addons/postprocessing/OutputPass.js')
  ]);
  EffComp = ec.EffectComposer;
  RenPass = rp.RenderPass;
  BloomPass = bp.UnrealBloomPass;
  OutPass = op.OutputPass;
} catch(e) { console.warn('Post-processing unavailable:', e); }

const T = THREE;

/* ── Constants (meters) ── */
const TK = { L:4, W:2.045, H:1.98 };
const IR = { L:1, W:0.82, H:1.5 };
const TB = { L:1.82, W:0.75, TH:0.05, EL:0.75 };
const CB = { S:0.762 };
const ST = { L:0.6, W:0.5, H:0.8 };

/* ── Scene ── */
const scene = new T.Scene();
scene.background = new T.Color(0x060608);
scene.fog = new T.FogExp2(0x060608, 0.028);

const cam = new T.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 80);
const tgt = new T.Vector3(TK.W/2, TK.H*0.32, TK.L/2);
const camStart = new T.Vector3(10, 8, 12);
const camEnd = new T.Vector3(4.2, 2.6, 5.8);
cam.position.copy(camStart);

/* ── WebGL Renderer ── */
const ren = new T.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
ren.setSize(innerWidth, innerHeight);
ren.setPixelRatio(Math.min(devicePixelRatio, 2));
ren.shadowMap.enabled = true;
ren.shadowMap.type = T.PCFSoftShadowMap;
ren.toneMapping = T.ACESFilmicToneMapping;
ren.toneMappingExposure = 1.1;
document.getElementById('c').appendChild(ren.domElement);

/* ── PBR Environment ── */
if (RoomEnv) {
  try {
    const pmrem = new T.PMREMGenerator(ren);
    scene.environment = pmrem.fromScene(new RoomEnv(), 0.04).texture;
    pmrem.dispose();
  } catch(e) { console.warn('PMREM failed:', e); }
}

/* ── Post-processing (optional) ── */
let composer = null;
let bloom = null;
if (EffComp && RenPass && BloomPass && OutPass) {
  try {
    composer = new EffComp(ren);
    composer.addPass(new RenPass(scene, cam));
    bloom = new BloomPass(new T.Vector2(innerWidth, innerHeight), 0.25, 0.6, 0.88);
    composer.addPass(bloom);
    composer.addPass(new OutPass());
  } catch(e) { console.warn('Composer failed:', e); composer = null; }
}

/* ── CSS2D Renderer ── */
const lr = new CSS2DRenderer();
lr.setSize(innerWidth, innerHeight);
lr.domElement.style.position = 'absolute';
lr.domElement.style.top = '0';
lr.domElement.style.pointerEvents = 'none';
document.getElementById('c').appendChild(lr.domElement);

/* ── Controls ── */
const ctl = new OrbitControls(cam, ren.domElement);
ctl.target.copy(tgt);
ctl.enableDamping = true;
ctl.dampingFactor = 0.05;
ctl.minDistance = 1;
ctl.maxDistance = 18;
ctl.update();

/* ── Lighting ── */
scene.add(new T.AmbientLight(0x222233, 0.5));
scene.add(new T.HemisphereLight(0x8899bb, 0x221100, 0.4));

const sun = new T.DirectionalLight(0xfff6e8, 1.8);
sun.position.set(5, 9, 3);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.left = -8; sun.shadow.camera.right = 8;
sun.shadow.camera.top = 8; sun.shadow.camera.bottom = -8;
sun.shadow.bias = -0.0003;
scene.add(sun);

scene.add(new T.PointLight(0xffe8c0, 0.5, 8).copy
  ? Object.assign(new T.PointLight(0xffe8c0, 0.5, 8), {})
  : new T.PointLight(0xffe8c0, 0.5, 8));
const pl1 = new T.PointLight(0xffe8c0, 0.5, 8);
pl1.position.set(TK.W/2, TK.H-0.05, TK.L/2); scene.add(pl1);
const pl2 = new T.PointLight(0xc0d8ff, 0.25, 6);
pl2.position.set(TK.W/2, 0.4, TK.L-0.3); scene.add(pl2);

/* ── Ground ── */
const gnd = new T.Mesh(new T.PlaneGeometry(40,40), new T.MeshStandardMaterial({color:0x080808, roughness:0.92}));
gnd.rotation.x = -Math.PI/2; gnd.position.y = -0.005; gnd.receiveShadow = true; scene.add(gnd);
scene.add(new T.GridHelper(40, 80, 0x111114, 0x0c0c0e));

/* ── Groups ── */
const G = {};
['i','t','z','e','s','w','l'].forEach(k => { G[k] = new T.Group(); scene.add(G[k]); });

/* ── Material registry ── */
const mats = {};
const SCH = {
  schema: { irm:0xd4860a, tbl:0x7c3aed, pad:0x6d28d9, cab:0x1d4ed8, sto:0x047857, ring:0xf59e0b },
  real:   { irm:0xf0ebe4, tbl:0xb8b4ac, pad:0xd5d0c8, cab:0x3a3a3a, sto:0x4a4a4a, ring:0xcccccc }
};

/* ── Helpers ── */
function pbox(w,h,d, col, met, rou, cc) {
  const geo = new T.BoxGeometry(w,h,d);
  const mat = new T.MeshPhysicalMaterial({
    color: col, metalness: met||0.5, roughness: rou||0.3,
    clearcoat: cc||0.5, clearcoatRoughness: 0.15, envMapIntensity: 1.2
  });
  const mesh = new T.Mesh(geo, mat);
  mesh.castShadow = true; mesh.receiveShadow = true;
  const lc = new T.Color(col).lerp(new T.Color(0xffffff), 0.25);
  mesh.add(new T.LineSegments(
    new T.EdgesGeometry(geo),
    new T.LineBasicMaterial({ color: lc, transparent:true, opacity:0.1 })
  ));
  return { mesh, mat };
}

function lbl(txt, dim, cls) {
  const d = document.createElement('div');
  d.className = 'l3 ' + cls;
  d.innerHTML = txt + (dim ? '<span class="dm">'+dim+'</span>' : '');
  return new CSS2DObject(d);
}

/* ══════════════════════════════════════ */
/* ── TRUCK WALLS ── */
/* ══════════════════════════════════════ */
const wm = new T.MeshPhysicalMaterial({ color:0x667788, transparent:true, opacity:0.04, side:T.DoubleSide, depthWrite:false, roughness:0.3 });

// Reflective floor
const flr = new T.Mesh(new T.PlaneGeometry(TK.W, TK.L), new T.MeshPhysicalMaterial({ color:0x151518, roughness:0.25, metalness:0.35, clearcoat:0.8, clearcoatRoughness:0.2 }));
flr.rotation.x = -Math.PI/2; flr.position.set(TK.W/2, 0.002, TK.L/2); flr.receiveShadow = true; G.w.add(flr);

// Ceiling
const cl = new T.Mesh(new T.PlaneGeometry(TK.W, TK.L), wm.clone());
cl.rotation.x = Math.PI/2; cl.position.set(TK.W/2, TK.H, TK.L/2); G.w.add(cl);

// Ceiling light strip
const ls = new T.Mesh(new T.BoxGeometry(0.08, 0.01, TK.L-0.4), new T.MeshStandardMaterial({ color:0xffffff, emissive:0xfff8ee, emissiveIntensity:0.7 }));
ls.position.set(TK.W/2, TK.H-0.005, TK.L/2); G.w.add(ls);

// Side walls
const sGeo = new T.PlaneGeometry(TK.L, TK.H);
const dw = new T.Mesh(sGeo, wm.clone()); dw.rotation.y = Math.PI/2; dw.position.set(0, TK.H/2, TK.L/2); G.w.add(dw);
const pw = new T.Mesh(sGeo.clone(), wm.clone()); pw.rotation.y = -Math.PI/2; pw.position.set(TK.W, TK.H/2, TK.L/2); G.w.add(pw);

// Front wall
const fwm = new T.Mesh(new T.PlaneGeometry(TK.W, TK.H), wm.clone());
fwm.position.set(TK.W/2, TK.H/2, 0); G.w.add(fwm);

// Rear frame
const fm = new T.MeshPhysicalMaterial({ color:0x404040, metalness:0.7, roughness:0.35, clearcoat:0.4 });
[0.12, TK.W-0.12].forEach(x => {
  const p = new T.Mesh(new T.BoxGeometry(0.06, TK.H, 0.06), fm);
  p.position.set(x, TK.H/2, TK.L); p.castShadow = true; G.w.add(p);
});
const tb = new T.Mesh(new T.BoxGeometry(TK.W-0.16, 0.06, 0.06), fm);
tb.position.set(TK.W/2, TK.H-0.03, TK.L); G.w.add(tb);
const bb2 = new T.Mesh(new T.BoxGeometry(TK.W-0.16, 0.06, 0.06), fm);
bb2.position.set(TK.W/2, 0.03, TK.L); G.w.add(bb2);

// Wireframe box
const bxE = new T.LineSegments(new T.EdgesGeometry(new T.BoxGeometry(TK.W, TK.H, TK.L)), new T.LineBasicMaterial({ color:0x333338, transparent:true, opacity:0.5 }));
bxE.position.set(TK.W/2, TK.H/2, TK.L/2); G.w.add(bxE);

// Cab
const cabB = new T.Mesh(new T.BoxGeometry(TK.W+0.2, 1.5, 1.4), new T.MeshPhysicalMaterial({ color:0x141416, roughness:0.6, metalness:0.5, clearcoat:0.3 }));
cabB.position.set(TK.W/2, 0.75, -0.7); cabB.castShadow = true; G.w.add(cabB);
cabB.add(new T.LineSegments(new T.EdgesGeometry(cabB.geometry), new T.LineBasicMaterial({ color:0x222, transparent:true, opacity:0.3 })));

// Windshield
const ws = new T.Mesh(new T.PlaneGeometry(TK.W-0.2, 0.5), new T.MeshPhysicalMaterial({ color:0x4488bb, transparent:true, opacity:0.2, metalness:0.95, roughness:0.05, clearcoat:1 }));
ws.position.set(TK.W/2, 1.1, -1.39); G.w.add(ws);

// Wheels
const wGeo = new T.CylinderGeometry(0.3, 0.3, 0.2, 20);
const wMat = new T.MeshStandardMaterial({ color:0x0e0e0e, roughness:0.85 });
[[-0.15,0.3,-0.5],[TK.W+0.15,0.3,-0.5],[-0.15,0.3,TK.L-0.3],[TK.W+0.15,0.3,TK.L-0.3]].forEach(p => {
  const w = new T.Mesh(wGeo, wMat); w.rotation.z = Math.PI/2;
  w.position.set(p[0],p[1],p[2]); w.castShadow = true; G.w.add(w);
});

/* ══════════════════════════════════════ */
/* ── IRM ── */
/* ══════════════════════════════════════ */
const { mesh:irmM, mat:irmMat } = pbox(IR.W, IR.H, IR.L, SCH.schema.irm, 0.65, 0.15, 0.9);
irmM.position.set(IR.W/2, IR.H/2, IR.L/2); G.i.add(irmM); mats.irm = irmMat;

// Bore tunnel
const boreMat = new T.MeshStandardMaterial({ color:0x0a0a0a, side:T.BackSide, roughness:0.95 });
const boreM = new T.Mesh(new T.CylinderGeometry(0.27, 0.27, IR.L+0.04, 48, 1, true), boreMat);
boreM.rotation.x = Math.PI/2; boreM.position.set(IR.W/2, IR.H/2, IR.L/2); G.i.add(boreM);

// Bore ring
const ringMat = new T.MeshPhysicalMaterial({ color:SCH.schema.ring, emissive:SCH.schema.ring, emissiveIntensity:0.5, metalness:0.95, roughness:0.05, clearcoat:1 });
const ringM = new T.Mesh(new T.TorusGeometry(0.27, 0.022, 16, 64), ringMat);
ringM.position.set(IR.W/2, IR.H/2, IR.L); G.i.add(ringM); mats.ring = ringMat;

// Glow
const glowMat = new T.MeshBasicMaterial({ color:SCH.schema.ring, transparent:true, opacity:0.06, side:T.DoubleSide });
const glowM = new T.Mesh(new T.TorusGeometry(0.27, 0.07, 8, 64), glowMat);
glowM.position.copy(ringM.position); G.i.add(glowM);

// Console panel + LEDs
const cpM = new T.Mesh(new T.BoxGeometry(0.28, 0.012, 0.18), new T.MeshPhysicalMaterial({ color:0x111118, emissive:0x112233, emissiveIntensity:0.3, metalness:0.85, roughness:0.15, clearcoat:1 }));
cpM.position.set(IR.W/2, IR.H+0.007, IR.L*0.3); G.i.add(cpM);
[[-0.08,0x22ff44],[0,0x22ff44],[0.08,0x4488ff]].forEach(([dx,c]) => {
  const led = new T.Mesh(new T.SphereGeometry(0.005,8,8), new T.MeshBasicMaterial({color:c}));
  led.position.set(IR.W/2+dx, IR.H+0.018, IR.L*0.3-0.05); G.i.add(led);
});

const irmL = lbl('IRM','1.0×0.82×1.50m — Console int.','ci');
irmL.position.set(IR.W/2, IR.H+0.22, IR.L/2); G.l.add(irmL);

/* ══════════════════════════════════════ */
/* ── TABLE PATIENT ── */
/* ══════════════════════════════════════ */
const { mesh:tblM, mat:tblMat } = pbox(TB.W, TB.TH, TB.L, SCH.schema.tbl, 0.2, 0.5, 0.4);
tblM.position.set(IR.W/2, TB.EL, IR.L+TB.L/2); G.t.add(tblM); mats.tbl = tblMat;

// Cushion
const padMat = new T.MeshPhysicalMaterial({ color:SCH.schema.pad, roughness:0.85, metalness:0, clearcoat:0.1 });
const padM = new T.Mesh(new T.BoxGeometry(TB.W-0.06, 0.035, TB.L-0.08), padMat);
padM.position.set(IR.W/2, TB.EL+0.042, IR.L+TB.L/2); G.t.add(padM); mats.pad = padMat;

// Legs
const legMat = new T.MeshPhysicalMaterial({ color:0x555555, metalness:0.9, roughness:0.15 });
const legGeo = new T.CylinderGeometry(0.016, 0.016, TB.EL-TB.TH/2, 10);
[[0.3,0.06],[0.3,TB.L-0.06],[-0.3,0.06],[-0.3,TB.L-0.06]].forEach(([dx,dz]) => {
  const l = new T.Mesh(legGeo, legMat);
  l.position.set(IR.W/2+dx, (TB.EL-TB.TH/2)/2, IR.L+dz);
  l.castShadow = true; G.t.add(l);
});

// Rails
const railMat = new T.MeshPhysicalMaterial({ color:0x888888, metalness:0.95, roughness:0.1, clearcoat:1 });
[-1,1].forEach(s => {
  const rail = new T.Mesh(new T.BoxGeometry(0.025, 0.02, TB.L+0.35), railMat);
  rail.position.set(IR.W/2+s*(TB.W/2+0.02), TB.EL-0.025, IR.L+TB.L/2-0.12);
  G.t.add(rail);
});

const tblL = lbl('Table patient','1.82×0.75m','ct');
tblL.position.set(IR.W/2, TB.EL+0.35, IR.L+TB.L/2); G.l.add(tblL);

/* ══════════════════════════════════════ */
/* ── 90° CLEARANCE ZONE ── */
/* ══════════════════════════════════════ */
const cx = IR.W, cz = IR.L;
const clrMat = new T.MeshPhysicalMaterial({ color:0xef4444, transparent:true, opacity:0.04, side:T.DoubleSide, depthWrite:false });
const clrM = new T.Mesh(new T.CylinderGeometry(1, 1, TK.H, 64, 1, false, 0, Math.PI/2), clrMat);
clrM.position.set(cx, TK.H/2, cz); G.z.add(clrM);

// Floor arc + radii
const ap = [];
for (let i=0; i<=64; i++) { const th = i/64*Math.PI/2; ap.push(cx+Math.sin(th), 0.008, cz+Math.cos(th)); }
ap.push(cx, 0.008, cz, cx, 0.008, cz+1);
const arcGeo = new T.BufferGeometry(); arcGeo.setAttribute('position', new T.Float32BufferAttribute(ap, 3));
const arcL = new T.Line(arcGeo, new T.LineDashedMaterial({ color:0xef4444, dashSize:0.05, gapSize:0.035, transparent:true, opacity:0.45 }));
arcL.computeLineDistances(); G.z.add(arcL);
const arcT = arcL.clone(); arcT.position.y = TK.H-0.015; arcT.computeLineDistances(); G.z.add(arcT);

// Vertical lines
const vMat = new T.LineBasicMaterial({ color:0xef4444, transparent:true, opacity:0.08 });
for (let i=0; i<=6; i++) {
  const th = i/6*Math.PI/2;
  const pts = [cx+Math.sin(th), 0.005, cz+Math.cos(th), cx+Math.sin(th), TK.H-0.005, cz+Math.cos(th)];
  const vg = new T.BufferGeometry(); vg.setAttribute('position', new T.Float32BufferAttribute(pts, 3));
  G.z.add(new T.LineSegments(vg, vMat));
}

const clrL = lbl('Zone dégagement','90° — R: 1.0 m','cz');
clrL.position.set(cx+0.5, 0.22, cz+0.5); G.l.add(clrL);

/* ══════════════════════════════════════ */
/* ── ARMOIRE ÉLECTRIQUE ── */
/* ══════════════════════════════════════ */
const cabZ = 2.91 + CB.S/2;
const { mesh:cabMesh, mat:cabMat } = pbox(CB.S, CB.S, CB.S, SCH.schema.cab, 0.6, 0.25, 0.7);
cabMesh.position.set(CB.S/2, CB.S/2, cabZ); G.e.add(cabMesh); mats.cab = cabMat;

const hdl = new T.Mesh(new T.BoxGeometry(0.015, 0.1, 0.015), new T.MeshPhysicalMaterial({ color:0xaaaaaa, metalness:0.95, roughness:0.1 }));
hdl.position.set(CB.S-0.01, CB.S/2, cabZ+CB.S/2+0.015); G.e.add(hdl);

const cabL = lbl('Armoire élec.','30" cube (0.762m)','ce');
cabL.position.set(CB.S/2, CB.S+0.15, cabZ); G.l.add(cabL);

/* ══════════════════════════════════════ */
/* ── RANGEMENT ── */
/* ══════════════════════════════════════ */
const stZ = 2.46 + ST.L/2;
const { mesh:stoMesh, mat:stoMat } = pbox(ST.W, ST.H, ST.L, SCH.schema.sto, 0.35, 0.45, 0.5);
stoMesh.position.set(TK.W-ST.W/2, ST.H/2, stZ); G.s.add(stoMesh); mats.sto = stoMat;

const stoL = lbl('Rangement','0.60×0.50×0.80m','cs');
stoL.position.set(TK.W-ST.W/2, ST.H+0.15, stZ); G.l.add(stoL);

/* ── Dimension labels ── */
function dLine(a,b) {
  const g = new T.BufferGeometry().setFromPoints([new T.Vector3(...a), new T.Vector3(...b)]);
  const l = new T.Line(g, new T.LineDashedMaterial({ color:0xf59e0b, dashSize:0.05, gapSize:0.04, transparent:true, opacity:0.2 }));
  l.computeLineDistances(); return l;
}
G.l.add(dLine([TK.W+0.25,0.005,0],[TK.W+0.25,0.005,TK.L]));
const d1 = lbl('4.00 m','','cd'); d1.position.set(TK.W+0.25, 0.005, TK.L/2); G.l.add(d1);
G.l.add(dLine([0,0.005,TK.L+0.25],[TK.W,0.005,TK.L+0.25]));
const d2 = lbl('2.045 m','','cd'); d2.position.set(TK.W/2, 0.005, TK.L+0.25); G.l.add(d2);
G.l.add(dLine([TK.W+0.25,0,0],[TK.W+0.25,TK.H,0]));
const d3 = lbl('1.98 m','','cd'); d3.position.set(TK.W+0.25, TK.H/2, 0); G.l.add(d3);

// Orientation
const oF = lbl('CABINE ◂','','cd'); oF.position.set(TK.W/2, TK.H/2, -0.45); G.l.add(oF);
const oR = lbl('▸ ARRIÈRE','','cd'); oR.position.set(TK.W/2, TK.H/2, TK.L+0.45); G.l.add(oR);
const oD = lbl('CONDUCTEUR','','cd'); oD.position.set(-0.35, TK.H/2, TK.L/2); G.l.add(oD);
const oP = lbl('PASSAGER','','cd'); oP.position.set(TK.W+0.35, TK.H/2, TK.L/2); G.l.add(oP);

/* ══════════════════════════════════════ */
/* ── RENDER LOOP ── */
/* ══════════════════════════════════════ */
let ip = 0;
let tp = null, tf = null, ta = 0;
const ease = t => 1 - Math.pow(1-t, 3);

function doRender() {
  if (composer) composer.render();
  else ren.render(scene, cam);
  lr.render(scene, cam);
}

function animate() {
  requestAnimationFrame(animate);
  if (ip < 1) { ip = Math.min(ip + 0.006, 1); cam.position.lerpVectors(camStart, camEnd, ease(ip)); }
  if (tp) { ta = Math.min(ta + 0.015, 1); cam.position.lerpVectors(tf, tp, ease(ta)); if (ta >= 1) tp = null; }
  ctl.update();
  if (G.z.visible) clrMat.opacity = 0.03 + Math.sin(Date.now()*0.0015)*0.02;
  if (G.i.visible) { glowMat.opacity = 0.04 + Math.sin(Date.now()*0.0025)*0.04; ringMat.emissiveIntensity = 0.4 + Math.sin(Date.now()*0.003)*0.2; }
  doRender();
}
animate();

/* ── View presets ── */
const V = {
  hero: new T.Vector3(4.2, 2.6, 5.8),
  top:  new T.Vector3(TK.W/2, 7.5, TK.L/2+0.01),
  drv:  new T.Vector3(-3, 1.5, TK.L/2),
  pas:  new T.Vector3(TK.W+3, 1.5, TK.L/2),
  rear: new T.Vector3(TK.W/2, 1.4, TK.L+4),
  bore: new T.Vector3(IR.W/2+0.3, IR.H/2+0.15, IR.L+1.2),
  pat:  new T.Vector3(TK.W/2+0.6, 1.1, TK.L+2.5)
};
document.querySelectorAll('.vb[data-v]').forEach(b => b.addEventListener('click', () => {
  document.querySelectorAll('.vb').forEach(x => x.classList.remove('on'));
  b.classList.add('on');
  tf = cam.position.clone(); tp = V[b.dataset.v].clone(); ta = 0;
}));

/* ── Toggles ── */
const TM = {'t-i':'i','t-t':'t','t-z':'z','t-e':'e','t-s':'s','t-l':'l','t-w':'w'};
Object.entries(TM).forEach(([id,g]) => {
  document.getElementById(id).addEventListener('change', ev => { G[g].visible = ev.target.checked; });
});

/* ── Bloom toggle ── */
document.getElementById('t-real').addEventListener('change', ev => {
  const s = ev.target.checked ? SCH.real : SCH.schema;
  mats.irm.color.set(s.irm); mats.tbl.color.set(s.tbl); mats.pad.color.set(s.pad);
  mats.cab.color.set(s.cab); mats.sto.color.set(s.sto);
  mats.ring.color.set(s.ring); mats.ring.emissive.set(s.ring);
  glowMat.color.set(s.ring);
});

/* ── Screenshot ── */
document.getElementById('cap').addEventListener('click', () => {
  const s=3, w=innerWidth*s, h=innerHeight*s;
  ren.setSize(w,h); ren.setPixelRatio(1);
  if (composer) composer.setSize(w,h);
  doRender();
  const a = document.createElement('a');
  a.download = 'plan-irm-3d-faucon-ptr.png';
  a.href = ren.domElement.toDataURL('image/png');
  a.click();
  ren.setSize(innerWidth,innerHeight); ren.setPixelRatio(Math.min(devicePixelRatio,2));
  if (composer) composer.setSize(innerWidth,innerHeight);
});

/* ── Fullscreen ── */
document.getElementById('fs').addEventListener('click', () => {
  if (document.fullscreenElement) document.exitFullscreen();
  else document.documentElement.requestFullscreen();
});

/* ── Resize ── */
window.addEventListener('resize', () => {
  cam.aspect = innerWidth/innerHeight;
  cam.updateProjectionMatrix();
  ren.setSize(innerWidth, innerHeight);
  lr.setSize(innerWidth, innerHeight);
  if (composer) composer.setSize(innerWidth, innerHeight);
});

/* ── Done ── */
document.getElementById('ld').classList.add('hide');
console.log('Faucon PTR 3D loaded. Composer:', !!composer, '| Environment:', !!RoomEnv);

} catch(err) {
  console.error('3D init error:', err);
  document.getElementById('ld').style.display = 'none';
  const errDiv = document.getElementById('err');
  errDiv.style.display = 'flex';
  document.getElementById('errmsg').textContent = err.message || String(err);
}
</script>
</body>
</html>
