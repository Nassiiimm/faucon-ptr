<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vue 3D Architecte — IRM Mobile T350 14' — Faucon PTR</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#EDEBE8;color:#333;font-family:'Segoe UI',system-ui,sans-serif;overflow:hidden;width:100vw;height:100vh}
  #c{position:fixed;top:0;left:0;width:100%;height:100%}
  #ld{position:fixed;inset:0;background:#F0EDE8;z-index:999;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;transition:opacity .8s}
  #ld.hide{opacity:0;pointer-events:none}
  #ld .sp{width:30px;height:30px;border:3px solid #D5D0CA;border-top-color:#d97706;border-radius:50%;animation:spin .8s linear infinite}
  #ld p{font-size:12px;color:#78716c}
  @keyframes spin{to{transform:rotate(360deg)}}
  #err{position:fixed;inset:0;background:#F0EDE8;z-index:1000;display:none;align-items:center;justify-content:center;flex-direction:column;gap:12px;padding:40px}
  #err h2{color:#dc2626;font-size:18px}#err p{color:#78716c;font-size:13px;max-width:500px;text-align:center}#err code{background:#E8E5E0;padding:8px 16px;border-radius:8px;font-size:11px;color:#dc2626;max-width:90vw;overflow-x:auto}
  .P{position:fixed;top:14px;left:14px;background:rgba(255,255,255,.88);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:1px solid rgba(0,0,0,.07);border-radius:14px;padding:16px;width:240px;z-index:100;max-height:calc(100vh - 28px);overflow-y:auto;scrollbar-width:thin;scrollbar-color:#ccc transparent;box-shadow:0 4px 24px rgba(0,0,0,.06)}
  .P h1{font-size:16px;font-weight:700;color:#1a1a1a}.P h1 span{color:#d97706}
  .P .sub{font-size:9px;color:#78716c;margin-bottom:12px;letter-spacing:.4px}
  .S{font-size:8px;text-transform:uppercase;letter-spacing:1.3px;color:#a3a3a3;margin:12px 0 5px;font-weight:700}
  .vb{display:inline-block;background:rgba(0,0,0,.03);border:1px solid rgba(0,0,0,.08);border-radius:6px;color:#666;font-size:9.5px;padding:4px 9px;margin:2px;cursor:pointer;transition:all .15s;font-family:inherit}
  .vb:hover{border-color:#d97706;color:#d97706}.vb.on{background:rgba(217,119,6,.1);color:#d97706;border-color:rgba(217,119,6,.3);font-weight:600}
  .tr{display:flex;align-items:center;gap:6px;padding:2.5px 0}
  .tr input{accent-color:#d97706;cursor:pointer;width:13px;height:13px}
  .tr label{font-size:10.5px;color:#555;cursor:pointer}
  .dot{width:6px;height:6px;border-radius:2px;flex-shrink:0}
  .sg{display:grid;grid-template-columns:1fr 1fr;gap:2px;margin-top:3px}
  .si{font-size:8.5px;color:#888;padding:2px 0}.si strong{color:#555;display:block;font-size:9.5px}
  .lk{display:inline-block;margin-top:8px;font-size:9.5px;color:#d97706;text-decoration:none;opacity:.6;transition:opacity .2s}.lk:hover{opacity:1}
  .bb{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:100}
  .bb>div,.bb>button{background:rgba(255,255,255,.85);backdrop-filter:blur(12px);border:1px solid rgba(0,0,0,.06);border-radius:8px;padding:5px 12px;font-size:9.5px;color:#888;font-family:inherit;box-shadow:0 2px 8px rgba(0,0,0,.04)}
  .bb button{cursor:pointer;transition:all .15s;color:#666}.bb button:hover{border-color:#d97706;color:#d97706}
  .fs{position:fixed;top:14px;right:14px;background:rgba(255,255,255,.85);backdrop-filter:blur(12px);border:1px solid rgba(0,0,0,.06);border-radius:8px;padding:6px 10px;color:#888;font-size:15px;cursor:pointer;z-index:100;transition:all .15s;line-height:1;box-shadow:0 2px 8px rgba(0,0,0,.04)}.fs:hover{border-color:#d97706;color:#d97706}
  .l3{background:rgba(255,255,255,.92);backdrop-filter:blur(6px);border:1px solid rgba(0,0,0,.1);border-radius:5px;padding:3px 8px;font-size:10px;font-weight:600;white-space:nowrap;pointer-events:none;font-family:'Segoe UI',system-ui,sans-serif;line-height:1.35;box-shadow:0 1px 4px rgba(0,0,0,.06)}
  .l3.ci{color:#92400e;border-color:rgba(217,119,6,.3)}.l3.ct{color:#6b21a8;border-color:rgba(147,51,234,.3)}
  .l3.cz{color:#991b1b;border-color:rgba(220,38,38,.3)}.l3.ce{color:#1e40af;border-color:rgba(59,130,246,.3)}
  .l3.cs{color:#065f46;border-color:rgba(16,185,129,.3)}.l3.cd{color:#78716c;border-color:rgba(0,0,0,.06);font-weight:400;font-size:8.5px}
  .l3 .dm{font-size:7.5px;font-weight:400;opacity:.55;display:block}
  @media(max-width:640px){.P{width:185px;padding:10px}}
</style>
</head>
<body>

<div id="ld"><div class="sp"></div><p>Chargement de la vue architecte 3D...</p></div>
<div id="err"><h2>Erreur de chargement</h2><p>Le rendu 3D n'a pas pu demarrer.</p><code id="errmsg"></code><p style="margin-top:12px"><a href="plan-irm.html" style="color:#d97706">&#8592; Voir le plan 2D</a></p></div>
<div id="c"></div>

<div class="P">
  <h1>FAUCON <span>PTR</span></h1>
  <div class="sub">IRM Mobile T350 14' — Vue 3D architecte</div>
  <div class="S">Vues</div>
  <div>
    <button class="vb on" data-v="hero">Perspective</button>
    <button class="vb" data-v="top">Dessus</button>
    <button class="vb" data-v="drv">Conducteur</button>
    <button class="vb" data-v="pas">Passager</button>
    <button class="vb" data-v="rear">Arriere</button>
    <button class="vb" data-v="bore">Detail bore</button>
    <button class="vb" data-v="pat">Vue patient</button>
  </div>
  <div class="S">Rendu</div>
  <div class="tr"><input type="checkbox" id="t-sch"><label for="t-sch">Mode schema (couleurs codees)</label></div>
  <div class="S">Elements</div>
  <div class="tr"><input type="checkbox" id="t-i" checked><div class="dot" style="background:#d97706"></div><label for="t-i">IRM (1.0x0.82x1.50m)</label></div>
  <div class="tr"><input type="checkbox" id="t-t" checked><div class="dot" style="background:#9333ea"></div><label for="t-t">Table patient (1.82x0.75m)</label></div>
  <div class="tr"><input type="checkbox" id="t-z" checked><div class="dot" style="background:#dc2626"></div><label for="t-z">Zone degagement 90deg/1m</label></div>
  <div class="tr"><input type="checkbox" id="t-e" checked><div class="dot" style="background:#2563eb"></div><label for="t-e">Armoire electrique 30"&#179;</label></div>
  <div class="tr"><input type="checkbox" id="t-s" checked><div class="dot" style="background:#059669"></div><label for="t-s">Rangement</label></div>
  <div class="tr"><input type="checkbox" id="t-l" checked><label for="t-l">Labels</label></div>
  <div class="tr"><input type="checkbox" id="t-w" checked><label for="t-w">Parois</label></div>
  <div class="S">Vehicule</div>
  <div class="sg">
    <div class="si"><strong>Long.</strong>4.00 m</div>
    <div class="si"><strong>Larg.</strong>2.045 m</div>
    <div class="si"><strong>Haut.</strong>1.98 m</div>
    <div class="si"><strong>Deg.</strong>1.0m / 90deg</div>
  </div>
  <a href="plan-irm.html" class="lk">&#8592; Plan 2D technique</a>
</div>

<div class="bb">
  <div>Clic : rotation | Molette : zoom | Clic droit : pan</div>
  <button id="cap">Capture HD</button>
</div>
<button class="fs" id="fs" title="Plein ecran">&#x26F6;</button>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
<script type="module">
try {

const THREE = await import('three');
const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');
const { CSS2DRenderer, CSS2DObject } = await import('three/addons/renderers/CSS2DRenderer.js');

let RoomEnv = null;
try {
  const mod = await import('three/addons/environments/RoomEnvironment.js');
  RoomEnv = mod.RoomEnvironment;
} catch(e) { console.warn('RoomEnvironment unavailable:', e); }

const T = THREE;

/* ════════════════════════════════════════════════════════ */
/* ── CONSTANTS (meters) ────────────────────────────────── */
/* ════════════════════════════════════════════════════════ */
const TK = { L:4, W:2.045, H:1.98 };
const IR = { L:1, W:0.82, H:1.5 };
const TB = { L:1.82, W:0.75, TH:0.05, EL:0.75 };
const CB = { S:0.762 };
const ST = { L:0.6, W:0.5, H:0.8 };

/* Cabinet: passenger wall, Z=2.5 center */
const CAB_X = TK.W - CB.S/2;
const CAB_Z = 2.5;
/* Storage: passenger wall, Z=3.4 center */
const STO_X = TK.W - ST.W/2;
const STO_Z = 3.4;

/* ════════════════════════════════════════════════════════ */
/* ── SCENE ─────────────────────────────────────────────── */
/* ════════════════════════════════════════════════════════ */
const scene = new T.Scene();
scene.background = new T.Color(0xE8E5E0);

const cam = new T.PerspectiveCamera(38, innerWidth/innerHeight, 0.1, 80);
const tgt = new T.Vector3(TK.W/2, TK.H*0.32, TK.L/2);
const camStart = new T.Vector3(9, 7, 11);
const camEnd = new T.Vector3(4.8, 3.0, 6.2);
cam.position.copy(camStart);

/* ── WebGL Renderer ── */
const ren = new T.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
ren.setSize(innerWidth, innerHeight);
ren.setPixelRatio(Math.min(devicePixelRatio, 2));
ren.shadowMap.enabled = true;
ren.shadowMap.type = T.PCFSoftShadowMap;
ren.toneMapping = T.ACESFilmicToneMapping;
ren.toneMappingExposure = 1.15;
ren.outputColorSpace = T.SRGBColorSpace;
document.getElementById('c').appendChild(ren.domElement);

/* ── PBR Environment ── */
if (RoomEnv) {
  try {
    const pmrem = new T.PMREMGenerator(ren);
    scene.environment = pmrem.fromScene(new RoomEnv(), 0.04).texture;
    pmrem.dispose();
  } catch(e) { console.warn('PMREM failed:', e); }
}

/* ── CSS2D Renderer ── */
const lr = new CSS2DRenderer();
lr.setSize(innerWidth, innerHeight);
lr.domElement.style.position = 'absolute';
lr.domElement.style.top = '0';
lr.domElement.style.pointerEvents = 'none';
document.getElementById('c').appendChild(lr.domElement);

/* ── Controls ── */
const ctl = new OrbitControls(cam, ren.domElement);
ctl.target.copy(tgt);
ctl.enableDamping = true;
ctl.dampingFactor = 0.06;
ctl.minDistance = 1;
ctl.maxDistance = 18;
ctl.update();

/* ════════════════════════════════════════════════════════ */
/* ── LIGHTING (Clinical / Bright) ──────────────────────── */
/* ════════════════════════════════════════════════════════ */
scene.add(new T.AmbientLight(0xffffff, 0.55));
scene.add(new T.HemisphereLight(0xffffff, 0xD8D0C8, 0.45));

const sun = new T.DirectionalLight(0xFFF8F0, 1.3);
sun.position.set(5, 9, 4);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.left = -6; sun.shadow.camera.right = 6;
sun.shadow.camera.top = 6; sun.shadow.camera.bottom = -6;
sun.shadow.bias = -0.0002;
sun.shadow.radius = 3;
scene.add(sun);

/* Fill light from rear */
const fill = new T.DirectionalLight(0xE8F0FF, 0.4);
fill.position.set(-2, 5, -3);
scene.add(fill);

/* Interior ceiling lights */
for (let z = 0.7; z < TK.L; z += 1.1) {
  const pl = new T.PointLight(0xFFFAF0, 0.35, 4, 1.5);
  pl.position.set(TK.W/2, TK.H - 0.04, z);
  scene.add(pl);
}

/* ════════════════════════════════════════════════════════ */
/* ── GROUND ────────────────────────────────────────────── */
/* ════════════════════════════════════════════════════════ */
const gnd = new T.Mesh(
  new T.PlaneGeometry(50, 50),
  new T.MeshStandardMaterial({ color: 0xD0CCC5, roughness: 0.85 })
);
gnd.rotation.x = -Math.PI/2;
gnd.position.y = -0.005;
gnd.receiveShadow = true;
scene.add(gnd);

const grid = new T.GridHelper(50, 100, 0xC8C4BC, 0xD5D0CA);
grid.position.y = -0.004;
scene.add(grid);

/* ════════════════════════════════════════════════════════ */
/* ── GROUPS ────────────────────────────────────────────── */
/* ════════════════════════════════════════════════════════ */
const G = {};
['i','t','z','e','s','w','l'].forEach(k => { G[k] = new T.Group(); scene.add(G[k]); });

/* ════════════════════════════════════════════════════════ */
/* ── MATERIAL HELPERS ──────────────────────────────────── */
/* ════════════════════════════════════════════════════════ */
const mats = {};
const COL = {
  real: { irm:0xF5F3F0, irmBase:0x555555, tbl:0xB0B0B0, pad:0xE8E5DF, cab:0x3A3A3A, sto:0xC8C4BE, ring:0xB8B8B8, accent:0xA0A8B0 },
  schema: { irm:0xd4860a, irmBase:0x8B5E0A, tbl:0x7c3aed, pad:0x6d28d9, cab:0x1d4ed8, sto:0x047857, ring:0xf59e0b, accent:0xf59e0b }
};

function mkMat(col, met, rou, cc) {
  return new T.MeshPhysicalMaterial({
    color: col, metalness: met||0, roughness: rou||0.5,
    clearcoat: cc||0, clearcoatRoughness: 0.2, envMapIntensity: 0.8
  });
}

function addEdge(mesh, opacity) {
  const lc = new T.Color(mesh.material.color).lerp(new T.Color(0x000000), 0.15);
  mesh.add(new T.LineSegments(
    new T.EdgesGeometry(mesh.geometry),
    new T.LineBasicMaterial({ color: lc, transparent: true, opacity: opacity||0.08 })
  ));
}

function lbl(txt, dim, cls) {
  const d = document.createElement('div');
  d.className = 'l3 ' + cls;
  d.innerHTML = txt + (dim ? '<span class="dm">'+dim+'</span>' : '');
  return new CSS2DObject(d);
}

/* ════════════════════════════════════════════════════════ */
/* ── TRUCK STRUCTURE ───────────────────────────────────── */
/* ════════════════════════════════════════════════════════ */
const wallMat = new T.MeshPhysicalMaterial({
  color: 0xF0EDE8, transparent: true, opacity: 0.3,
  side: T.DoubleSide, depthWrite: false, roughness: 0.7
});

/* Interior floor — medical vinyl */
const flrMat = mkMat(0xD5D0CA, 0.05, 0.55, 0.15);
const flr = new T.Mesh(new T.PlaneGeometry(TK.W, TK.L), flrMat);
flr.rotation.x = -Math.PI/2; flr.position.set(TK.W/2, 0.002, TK.L/2);
flr.receiveShadow = true; G.w.add(flr);

/* Floor tile seams */
const seamMat = new T.LineBasicMaterial({ color: 0xC5C0B8, transparent: true, opacity: 0.4 });
for (let z = 0.5; z <= TK.L; z += 0.5) {
  const g = new T.BufferGeometry().setFromPoints([new T.Vector3(0,0.003,z), new T.Vector3(TK.W,0.003,z)]);
  G.w.add(new T.Line(g, seamMat));
}
for (let x = 0.5; x <= TK.W; x += 0.5) {
  const g = new T.BufferGeometry().setFromPoints([new T.Vector3(x,0.003,0), new T.Vector3(x,0.003,TK.L)]);
  G.w.add(new T.Line(g, seamMat));
}

/* Ceiling */
const ceil = new T.Mesh(new T.PlaneGeometry(TK.W, TK.L), wallMat.clone());
ceil.material.opacity = 0.15;
ceil.rotation.x = Math.PI/2; ceil.position.set(TK.W/2, TK.H, TK.L/2); G.w.add(ceil);

/* LED strip lights on ceiling */
for (let z = 0.5; z < TK.L; z += 1.1) {
  const led = new T.Mesh(
    new T.BoxGeometry(0.6, 0.008, 0.15),
    new T.MeshStandardMaterial({ color: 0xFFFFFF, emissive: 0xFFFAF0, emissiveIntensity: 0.6 })
  );
  led.position.set(TK.W/2, TK.H - 0.005, z); G.w.add(led);
}

/* Side walls */
const sGeo = new T.PlaneGeometry(TK.L, TK.H);
const dw = new T.Mesh(sGeo, wallMat.clone()); dw.rotation.y = Math.PI/2; dw.position.set(0, TK.H/2, TK.L/2); G.w.add(dw);
const pw = new T.Mesh(sGeo.clone(), wallMat.clone()); pw.rotation.y = -Math.PI/2; pw.position.set(TK.W, TK.H/2, TK.L/2); G.w.add(pw);

/* Front wall */
const fwm = new T.Mesh(new T.PlaneGeometry(TK.W, TK.H), wallMat.clone());
fwm.position.set(TK.W/2, TK.H/2, 0); G.w.add(fwm);

/* Wall panel seam lines */
const wpMat = new T.LineBasicMaterial({ color: 0xD0CCC5, transparent: true, opacity: 0.3 });
/* Driver wall vertical seams */
for (let z = 1; z < TK.L; z += 1) {
  const g = new T.BufferGeometry().setFromPoints([new T.Vector3(0.001, 0.08, z), new T.Vector3(0.001, TK.H-0.01, z)]);
  G.w.add(new T.Line(g, wpMat));
}
/* Passenger wall vertical seams */
for (let z = 1; z < TK.L; z += 1) {
  const g = new T.BufferGeometry().setFromPoints([new T.Vector3(TK.W-0.001, 0.08, z), new T.Vector3(TK.W-0.001, TK.H-0.01, z)]);
  G.w.add(new T.Line(g, wpMat));
}

/* Baseboards */
const bbMat = mkMat(0x909090, 0.3, 0.5, 0.2);
const bbH = 0.06;
const bbDrv = new T.Mesh(new T.BoxGeometry(0.008, bbH, TK.L), bbMat);
bbDrv.position.set(0.004, bbH/2, TK.L/2); G.w.add(bbDrv);
const bbPas = new T.Mesh(new T.BoxGeometry(0.008, bbH, TK.L), bbMat);
bbPas.position.set(TK.W-0.004, bbH/2, TK.L/2); G.w.add(bbPas);
const bbFrt = new T.Mesh(new T.BoxGeometry(TK.W, bbH, 0.008), bbMat);
bbFrt.position.set(TK.W/2, bbH/2, 0.004); G.w.add(bbFrt);

/* Rear frame */
const fm = mkMat(0x606060, 0.6, 0.35, 0.3);
[0.06, TK.W-0.06].forEach(x => {
  const p = new T.Mesh(new T.BoxGeometry(0.05, TK.H, 0.05), fm);
  p.position.set(x, TK.H/2, TK.L); p.castShadow = true; G.w.add(p);
});
const topBar = new T.Mesh(new T.BoxGeometry(TK.W-0.08, 0.05, 0.05), fm);
topBar.position.set(TK.W/2, TK.H-0.025, TK.L); G.w.add(topBar);
const botBar = new T.Mesh(new T.BoxGeometry(TK.W-0.08, 0.05, 0.05), fm);
botBar.position.set(TK.W/2, 0.025, TK.L); G.w.add(botBar);

/* Wireframe outline */
const bxE = new T.LineSegments(
  new T.EdgesGeometry(new T.BoxGeometry(TK.W, TK.H, TK.L)),
  new T.LineBasicMaterial({ color: 0xA8A4A0, transparent: true, opacity: 0.35 })
);
bxE.position.set(TK.W/2, TK.H/2, TK.L/2); G.w.add(bxE);

/* Cab */
const cabBody = new T.Mesh(
  new T.BoxGeometry(TK.W+0.2, 1.5, 1.4),
  mkMat(0xE0DDD8, 0.2, 0.55, 0.2)
);
cabBody.position.set(TK.W/2, 0.75, -0.7); cabBody.castShadow = true; G.w.add(cabBody);
addEdge(cabBody, 0.12);

/* Windshield */
const ws = new T.Mesh(
  new T.PlaneGeometry(TK.W-0.2, 0.5),
  new T.MeshPhysicalMaterial({ color: 0x88BBDD, transparent: true, opacity: 0.25, metalness: 0.9, roughness: 0.05, clearcoat: 1 })
);
ws.position.set(TK.W/2, 1.15, -1.39); G.w.add(ws);

/* Wheels */
const wGeo = new T.CylinderGeometry(0.32, 0.32, 0.22, 24);
const wMat = new T.MeshStandardMaterial({ color: 0x222222, roughness: 0.85 });
[[-0.15,0.32,-0.5],[TK.W+0.15,0.32,-0.5],[-0.15,0.32,TK.L-0.3],[TK.W+0.15,0.32,TK.L-0.3]].forEach(p => {
  const w = new T.Mesh(wGeo, wMat); w.rotation.z = Math.PI/2;
  w.position.set(p[0],p[1],p[2]); w.castShadow = true; G.w.add(w);
});

/* ════════════════════════════════════════════════════════ */
/* ── IRM MACHINE (Multi-component, realistic white) ──── */
/* ════════════════════════════════════════════════════════ */

/* Base platform (wider, darker) */
const baseH = 0.12;
const baseMat = mkMat(COL.real.irmBase, 0.4, 0.4, 0.3);
const base = new T.Mesh(new T.BoxGeometry(IR.W+0.06, baseH, IR.L+0.03), baseMat);
base.position.set(IR.W/2, baseH/2, IR.L/2); base.castShadow = true; base.receiveShadow = true;
addEdge(base, 0.15); G.i.add(base); mats.irmBase = baseMat;

/* Main housing body */
const bodyH = IR.H - baseH - 0.04;
const bodyMat = mkMat(COL.real.irm, 0.05, 0.35, 0.6);
const body = new T.Mesh(new T.BoxGeometry(IR.W, bodyH, IR.L), bodyMat);
body.position.set(IR.W/2, baseH + bodyH/2, IR.L/2);
body.castShadow = true; body.receiveShadow = true;
addEdge(body, 0.06); G.i.add(body); mats.irm = bodyMat;

/* Top cover (slightly different shade) */
const topH = 0.04;
const topMat = mkMat(0xECEAE6, 0.08, 0.4, 0.5);
const topCover = new T.Mesh(new T.BoxGeometry(IR.W-0.02, topH, IR.L-0.02), topMat);
topCover.position.set(IR.W/2, IR.H - topH/2, IR.L/2);
topCover.castShadow = true; G.i.add(topCover);

/* Side accent strip (horizontal band at mid-height) */
const accentMat = mkMat(COL.real.accent, 0.5, 0.25, 0.7);
const accentH = 0.025;
/* Driver-facing side (X=0) accent */
const acc1 = new T.Mesh(new T.BoxGeometry(0.005, accentH, IR.L-0.06), accentMat);
acc1.position.set(0.003, baseH + bodyH*0.55, IR.L/2); G.i.add(acc1);
/* Passenger-facing side accent */
const acc2 = new T.Mesh(new T.BoxGeometry(0.005, accentH, IR.L-0.06), accentMat);
acc2.position.set(IR.W-0.003, baseH + bodyH*0.55, IR.L/2); G.i.add(acc2);
/* Front face accent */
const acc3 = new T.Mesh(new T.BoxGeometry(IR.W-0.06, accentH, 0.005), accentMat);
acc3.position.set(IR.W/2, baseH + bodyH*0.55, 0.003); G.i.add(acc3);
mats.accent = accentMat;

/* Ventilation slots (passenger-facing side) */
for (let i = 0; i < 5; i++) {
  const vent = new T.Mesh(
    new T.BoxGeometry(0.003, 0.008, 0.25),
    new T.MeshStandardMaterial({ color: 0x888888 })
  );
  vent.position.set(IR.W-0.002, baseH + bodyH*0.7 + i*0.04, IR.L*0.4);
  G.i.add(vent);
}

/* Bore tunnel (dark interior) */
const boreR = 0.26;
const boreMat = new T.MeshStandardMaterial({ color: 0x303030, side: T.BackSide, roughness: 0.92 });
const boreM = new T.Mesh(new T.CylinderGeometry(boreR, boreR, IR.L+0.02, 48, 1, true), boreMat);
boreM.rotation.x = Math.PI/2; boreM.position.set(IR.W/2, TB.EL, IR.L/2); G.i.add(boreM);

/* Bore inner ring (warm gray liner) */
const linerMat = new T.MeshStandardMaterial({ color: 0x505050, side: T.BackSide, roughness: 0.7 });
const liner = new T.Mesh(new T.CylinderGeometry(boreR-0.008, boreR-0.008, 0.06, 48, 1, true), linerMat);
liner.rotation.x = Math.PI/2; liner.position.set(IR.W/2, TB.EL, IR.L-0.02); G.i.add(liner);

/* Bore opening ring (accent torus) */
const ringMat = mkMat(COL.real.ring, 0.85, 0.08, 0.9);
const ringM = new T.Mesh(new T.TorusGeometry(boreR, 0.018, 16, 64), ringMat);
ringM.position.set(IR.W/2, TB.EL, IR.L+0.001); G.i.add(ringM); mats.ring = ringMat;

/* Control panel on top */
const cpM = new T.Mesh(
  new T.BoxGeometry(0.22, 0.01, 0.15),
  mkMat(0x222228, 0.7, 0.2, 0.8)
);
cpM.position.set(IR.W/2, IR.H+0.006, IR.L*0.35); G.i.add(cpM);

/* Status LEDs */
[[-0.06,0x22CC44],[0,0x22CC44],[0.06,0x3388FF]].forEach(([dx,c]) => {
  const led = new T.Mesh(new T.SphereGeometry(0.005,8,8), new T.MeshBasicMaterial({color:c}));
  led.position.set(IR.W/2+dx, IR.H+0.015, IR.L*0.35-0.04); G.i.add(led);
});

/* Front face panel (recessed) */
const fpMat = mkMat(0xEAE7E2, 0.03, 0.5, 0.3);
const fp = new T.Mesh(new T.BoxGeometry(IR.W-0.05, bodyH-0.06, 0.004), fpMat);
fp.position.set(IR.W/2, baseH + bodyH/2, 0.003); G.i.add(fp);

/* IRM label */
const irmL = lbl('IRM','1.0x0.82x1.50m — Console int.','ci');
irmL.position.set(IR.W/2, IR.H+0.25, IR.L/2); G.l.add(irmL);

/* ════════════════════════════════════════════════════════ */
/* ── PATIENT TABLE (Detailed) ──────────────────────────── */
/* ════════════════════════════════════════════════════════ */

/* Table top (frame) */
const tblMat = mkMat(COL.real.tbl, 0.85, 0.12, 0.8);
const tblM = new T.Mesh(new T.BoxGeometry(TB.W, TB.TH, TB.L), tblMat);
tblM.position.set(IR.W/2, TB.EL, IR.L+TB.L/2);
tblM.castShadow = true; tblM.receiveShadow = true;
addEdge(tblM, 0.08); G.t.add(tblM); mats.tbl = tblMat;

/* Cushion pad */
const padMat = mkMat(COL.real.pad, 0, 0.88, 0.05);
const padM = new T.Mesh(new T.BoxGeometry(TB.W-0.06, 0.04, TB.L-0.06), padMat);
padM.position.set(IR.W/2, TB.EL+0.045, IR.L+TB.L/2);
G.t.add(padM); mats.pad = padMat;

/* Headrest */
const hrMat = mkMat(0xE0DDD5, 0, 0.9, 0.05);
const hr = new T.Mesh(new T.BoxGeometry(0.25, 0.05, 0.2), hrMat);
hr.position.set(IR.W/2, TB.EL+0.05, IR.L+0.12); G.t.add(hr);

/* Table legs (stainless steel) */
const legMat = mkMat(0xA0A0A0, 0.9, 0.1, 0.7);
const legH = TB.EL - TB.TH/2;
const legGeo = new T.CylinderGeometry(0.018, 0.022, legH, 12);
[[0.28,0.08],[-0.28,0.08],[0.28,TB.L-0.08],[-0.28,TB.L-0.08]].forEach(([dx,dz]) => {
  const l = new T.Mesh(legGeo, legMat);
  l.position.set(IR.W/2+dx, legH/2, IR.L+dz);
  l.castShadow = true; G.t.add(l);
});

/* Cross bar between legs */
const crossMat = mkMat(0x999999, 0.85, 0.15, 0.5);
const cross1 = new T.Mesh(new T.BoxGeometry(0.56, 0.02, 0.02), crossMat);
cross1.position.set(IR.W/2, 0.15, IR.L+0.08); G.t.add(cross1);
const cross2 = new T.Mesh(new T.BoxGeometry(0.56, 0.02, 0.02), crossMat);
cross2.position.set(IR.W/2, 0.15, IR.L+TB.L-0.08); G.t.add(cross2);
const longBar = new T.Mesh(new T.BoxGeometry(0.02, 0.02, TB.L-0.16), crossMat);
longBar.position.set(IR.W/2, 0.15, IR.L+TB.L/2); G.t.add(longBar);

/* Guide rails (chrome) */
const railMat = mkMat(0xC0C0C0, 0.95, 0.05, 1);
[-1,1].forEach(s => {
  const rail = new T.Mesh(new T.BoxGeometry(0.02, 0.015, TB.L+0.3), railMat);
  rail.position.set(IR.W/2+s*(TB.W/2+0.02), TB.EL-0.02, IR.L+TB.L/2-0.1);
  G.t.add(rail);
});

/* Table label */
const tblL = lbl('Table patient','1.82x0.75m — H: 0.75m','ct');
tblL.position.set(IR.W/2, TB.EL+0.35, IR.L+TB.L/2); G.l.add(tblL);

/* ════════════════════════════════════════════════════════ */
/* ── 90deg CLEARANCE ZONE (Floor markings) ──────────────── */
/* ════════════════════════════════════════════════════════ */
const cx = IR.W, cz = IR.L;

/* Floor painted zone (thin disc sector) */
const zoneGeo = new T.CylinderGeometry(1, 1, 0.003, 64, 1, false, 0, Math.PI/2);
const zoneFill = new T.MeshStandardMaterial({ color: 0xE8A030, transparent: true, opacity: 0.1, side: T.DoubleSide, depthWrite: false });
const zoneDisc = new T.Mesh(zoneGeo, zoneFill);
zoneDisc.position.set(cx, 0.003, cz); G.z.add(zoneDisc);

/* Warning arc line (red dashed) on floor */
const arcPts = [];
for (let i=0; i<=80; i++) {
  const th = i/80 * Math.PI/2;
  arcPts.push(new T.Vector3(cx+Math.sin(th), 0.006, cz+Math.cos(th)));
}
const arcGeo = new T.BufferGeometry().setFromPoints(arcPts);
const arcLine = new T.Line(arcGeo, new T.LineDashedMaterial({ color:0xCC3333, dashSize:0.06, gapSize:0.04, transparent:true, opacity:0.7 }));
arcLine.computeLineDistances(); G.z.add(arcLine);

/* Radial boundary lines */
const radMat = new T.LineDashedMaterial({ color:0xCC3333, dashSize:0.04, gapSize:0.03, transparent:true, opacity:0.5 });
const rad1 = new T.Line(
  new T.BufferGeometry().setFromPoints([new T.Vector3(cx,0.006,cz), new T.Vector3(cx,0.006,cz+1)]), radMat
);
rad1.computeLineDistances(); G.z.add(rad1);
const rad2 = new T.Line(
  new T.BufferGeometry().setFromPoints([new T.Vector3(cx,0.006,cz), new T.Vector3(cx+1,0.006,cz)]), radMat
);
rad2.computeLineDistances(); G.z.add(rad2);

/* Intermediate radial lines (every 22.5 deg) */
for (let i=1; i<4; i++) {
  const th = i * Math.PI/8;
  const rd = new T.Line(
    new T.BufferGeometry().setFromPoints([
      new T.Vector3(cx, 0.006, cz),
      new T.Vector3(cx+Math.sin(th)*0.95, 0.006, cz+Math.cos(th)*0.95)
    ]),
    new T.LineBasicMaterial({ color:0xCC3333, transparent:true, opacity:0.15 })
  );
  G.z.add(rd);
}

/* "1.0 m" radius label on floor */
const th45 = Math.PI/4;
const rLbl = lbl('1.0 m','','cz');
rLbl.position.set(cx+Math.sin(th45)*0.55, 0.05, cz+Math.cos(th45)*0.55); G.l.add(rLbl);

/* Zone label */
const clrL = lbl('Zone degagement','90deg — R: 1.0 m','cz');
clrL.position.set(cx+0.5, 0.15, cz+0.55); G.l.add(clrL);

/* Vertical boundary posts (subtle) */
const vPostMat = new T.LineBasicMaterial({ color:0xCC3333, transparent:true, opacity:0.12 });
for (let i=0; i<=4; i++) {
  const th = i/4*Math.PI/2;
  const vg = new T.BufferGeometry().setFromPoints([
    new T.Vector3(cx+Math.sin(th), 0.005, cz+Math.cos(th)),
    new T.Vector3(cx+Math.sin(th), TK.H*0.3, cz+Math.cos(th))
  ]);
  G.z.add(new T.LineSegments(vg, vPostMat));
}

/* ════════════════════════════════════════════════════════ */
/* ── ELECTRICAL CABINET (Passenger wall) ────────────────── */
/* ════════════════════════════════════════════════════════ */
const cabMat = mkMat(COL.real.cab, 0.5, 0.35, 0.5);
const cabMesh = new T.Mesh(new T.BoxGeometry(CB.S, CB.S, CB.S), cabMat);
cabMesh.position.set(CAB_X, CB.S/2, CAB_Z);
cabMesh.castShadow = true; cabMesh.receiveShadow = true;
addEdge(cabMesh, 0.12); G.e.add(cabMesh); mats.cab = cabMat;

/* Door outline */
const doorOutline = new T.LineSegments(
  new T.EdgesGeometry(new T.BoxGeometry(CB.S-0.06, CB.S-0.06, 0.005)),
  new T.LineBasicMaterial({ color:0x555555, transparent:true, opacity:0.3 })
);
/* Door faces toward center of truck (-X direction from passenger wall) */
doorOutline.position.set(CAB_X - CB.S/2 + 0.02, CB.S/2, CAB_Z);
doorOutline.rotation.y = Math.PI/2;
G.e.add(doorOutline);

/* Handle */
const hdl = new T.Mesh(
  new T.BoxGeometry(0.015, 0.09, 0.015),
  mkMat(0xB0B0B0, 0.9, 0.1, 0.8)
);
hdl.position.set(CAB_X - CB.S/2 - 0.012, CB.S/2, CAB_Z + 0.12); G.e.add(hdl);

/* Ventilation slots on side */
for (let i = 0; i < 4; i++) {
  const vs = new T.Mesh(
    new T.BoxGeometry(0.2, 0.006, 0.003),
    new T.MeshStandardMaterial({ color: 0x555555 })
  );
  vs.position.set(CAB_X, CB.S*0.75 + i*0.035, CAB_Z + CB.S/2 + 0.002);
  G.e.add(vs);
}

/* Status LED */
const cabLed = new T.Mesh(new T.SphereGeometry(0.006,8,8), new T.MeshBasicMaterial({color:0x22CC44}));
cabLed.position.set(CAB_X - CB.S/2 - 0.01, CB.S*0.85, CAB_Z - 0.12); G.e.add(cabLed);

/* Label */
const cabL = lbl('Armoire elec.','30" cube (0.762m) — Cote passager','ce');
cabL.position.set(CAB_X, CB.S+0.18, CAB_Z); G.l.add(cabL);

/* ════════════════════════════════════════════════════════ */
/* ── STORAGE (Passenger wall) ──────────────────────────── */
/* ════════════════════════════════════════════════════════ */
const stoMat = mkMat(COL.real.sto, 0.15, 0.5, 0.3);
const stoMesh = new T.Mesh(new T.BoxGeometry(ST.W, ST.H, ST.L), stoMat);
stoMesh.position.set(STO_X, ST.H/2, STO_Z);
stoMesh.castShadow = true; stoMesh.receiveShadow = true;
addEdge(stoMesh, 0.1); G.s.add(stoMesh); mats.sto = stoMat;

/* Handle */
const stoHdl = new T.Mesh(
  new T.BoxGeometry(0.012, 0.07, 0.012),
  mkMat(0xA0A0A0, 0.85, 0.1, 0.7)
);
stoHdl.position.set(STO_X - ST.W/2 - 0.01, ST.H/2, STO_Z); G.s.add(stoHdl);

/* Label */
const stoL = lbl('Rangement','0.60x0.50x0.80m','cs');
stoL.position.set(STO_X, ST.H+0.15, STO_Z); G.l.add(stoL);

/* ════════════════════════════════════════════════════════ */
/* ── DIMENSION LABELS ──────────────────────────────────── */
/* ════════════════════════════════════════════════════════ */
function dLine(a,b) {
  const g = new T.BufferGeometry().setFromPoints([new T.Vector3(...a), new T.Vector3(...b)]);
  const l = new T.Line(g, new T.LineDashedMaterial({ color:0xB45309, dashSize:0.05, gapSize:0.04, transparent:true, opacity:0.35 }));
  l.computeLineDistances(); return l;
}
G.l.add(dLine([TK.W+0.3,0.005,0],[TK.W+0.3,0.005,TK.L]));
const d1 = lbl('4.00 m','','cd'); d1.position.set(TK.W+0.3, 0.005, TK.L/2); G.l.add(d1);
G.l.add(dLine([0,0.005,TK.L+0.3],[TK.W,0.005,TK.L+0.3]));
const d2 = lbl('2.045 m','','cd'); d2.position.set(TK.W/2, 0.005, TK.L+0.3); G.l.add(d2);
G.l.add(dLine([TK.W+0.3,0,0],[TK.W+0.3,TK.H,0]));
const d3 = lbl('1.98 m','','cd'); d3.position.set(TK.W+0.3, TK.H/2, 0); G.l.add(d3);

/* Orientation labels */
const oF = lbl('CABINE &#9666;','','cd'); oF.position.set(TK.W/2, TK.H/2, -0.5); G.l.add(oF);
const oR = lbl('&#9656; ARRIERE','','cd'); oR.position.set(TK.W/2, TK.H/2, TK.L+0.5); G.l.add(oR);
const oD = lbl('CONDUCTEUR','','cd'); oD.position.set(-0.4, TK.H/2, TK.L/2); G.l.add(oD);
const oP = lbl('PASSAGER','','cd'); oP.position.set(TK.W+0.4, TK.H/2, TK.L/2); G.l.add(oP);

/* ════════════════════════════════════════════════════════ */
/* ── RENDER LOOP ───────────────────────────────────────── */
/* ════════════════════════════════════════════════════════ */
let ip = 0;
let tp = null, tf = null, ta = 0;
const ease = t => 1 - Math.pow(1-t, 3);

function animate() {
  requestAnimationFrame(animate);
  if (ip < 1) { ip = Math.min(ip + 0.005, 1); cam.position.lerpVectors(camStart, camEnd, ease(ip)); }
  if (tp) { ta = Math.min(ta + 0.015, 1); cam.position.lerpVectors(tf, tp, ease(ta)); if (ta >= 1) tp = null; }
  ctl.update();
  ren.render(scene, cam);
  lr.render(scene, cam);
}
animate();

/* ── View presets ── */
const V = {
  hero: new T.Vector3(4.8, 3.0, 6.2),
  top:  new T.Vector3(TK.W/2, 7.5, TK.L/2+0.01),
  drv:  new T.Vector3(-3.5, 1.6, TK.L/2),
  pas:  new T.Vector3(TK.W+3.5, 1.6, TK.L/2),
  rear: new T.Vector3(TK.W/2, 1.5, TK.L+4.5),
  bore: new T.Vector3(IR.W/2+0.3, TB.EL+0.15, IR.L+1.3),
  pat:  new T.Vector3(TK.W/2+0.5, 1.1, TK.L+2.8)
};
document.querySelectorAll('.vb[data-v]').forEach(b => b.addEventListener('click', () => {
  document.querySelectorAll('.vb').forEach(x => x.classList.remove('on'));
  b.classList.add('on');
  tf = cam.position.clone(); tp = V[b.dataset.v].clone(); ta = 0;
}));

/* ── Element toggles ── */
const TM = {'t-i':'i','t-t':'t','t-z':'z','t-e':'e','t-s':'s','t-l':'l','t-w':'w'};
Object.entries(TM).forEach(([id,g]) => {
  document.getElementById(id).addEventListener('change', ev => { G[g].visible = ev.target.checked; });
});

/* ── Schema / Realistic color toggle ── */
document.getElementById('t-sch').addEventListener('change', ev => {
  const c = ev.target.checked ? COL.schema : COL.real;
  mats.irm.color.set(c.irm);
  mats.irmBase.color.set(c.irmBase);
  mats.tbl.color.set(c.tbl);
  mats.pad.color.set(c.pad);
  mats.cab.color.set(c.cab);
  mats.sto.color.set(c.sto);
  mats.ring.color.set(c.ring);
  mats.accent.color.set(c.accent);
});

/* ── Screenshot ── */
document.getElementById('cap').addEventListener('click', () => {
  const s=3, w=innerWidth*s, h=innerHeight*s;
  ren.setSize(w,h); ren.setPixelRatio(1);
  ren.render(scene, cam);
  lr.render(scene, cam);
  const a = document.createElement('a');
  a.download = 'plan-irm-3d-faucon-ptr.png';
  a.href = ren.domElement.toDataURL('image/png');
  a.click();
  ren.setSize(innerWidth,innerHeight); ren.setPixelRatio(Math.min(devicePixelRatio,2));
});

/* ── Fullscreen ── */
document.getElementById('fs').addEventListener('click', () => {
  if (document.fullscreenElement) document.exitFullscreen();
  else document.documentElement.requestFullscreen();
});

/* ── Resize ── */
window.addEventListener('resize', () => {
  cam.aspect = innerWidth/innerHeight;
  cam.updateProjectionMatrix();
  ren.setSize(innerWidth, innerHeight);
  lr.setSize(innerWidth, innerHeight);
});

/* ── Done ── */
document.getElementById('ld').classList.add('hide');
console.log('Faucon PTR 3D Architecte loaded. Environment:', !!RoomEnv);

} catch(err) {
  console.error('3D init error:', err);
  document.getElementById('ld').style.display = 'none';
  const errDiv = document.getElementById('err');
  errDiv.style.display = 'flex';
  document.getElementById('errmsg').textContent = err.message || String(err);
}
</script>
</body>
</html>
